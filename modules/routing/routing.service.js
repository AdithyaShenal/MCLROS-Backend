import axios from "axios";
import * as routingRepository from "./routing.repository.js";
import * as errors from "../../errors/errors.js";
import Route from "./routing.model.js";

const vehicles = [
  { vehicle_id: 1, capacity: 15, license_no: "ABC 1010", route: 1 },
  { vehicle_id: 2, capacity: 15, license_no: "ABC 2020", route: 2 },
  { vehicle_id: 3, capacity: 15, license_no: "ABC 3030", route: 3 },
  { vehicle_id: 4, capacity: 15, license_no: "ABC 4040", route: 4 },
  { vehicle_id: 5, capacity: 15, license_no: "ABC 5050", route: 5 },
  { vehicle_id: 6, capacity: 15, license_no: "ABC 6060", route: 6 },
];

const vehicle_capacities = [15, 15, 15, 15, 15, 15];
const depot = { lat: 7.019041, lon: 79.969565 };

export async function generateRoutesAuto() {
  const productions = await routingRepository.getPendingProduction();

  // Handling Error
  if (productions.length === 0) {
    throw new errors.NotFoundError(
      "No pending productions available at this moment"
    );
  }

  // Building VRP input
  const coords = [[depot.lon, depot.lat]];
  const demands = [0];
  const productionIndexMap = [null];

  productions.forEach((prod) => {
    coords.push([prod.farmer.location.lon, prod.farmer.location.lat]);
    demands.push(prod.volume);
    productionIndexMap.push(prod);
  });

  // Handling Error
  if (coords.length !== demands.length) {
    throw new errors.InternalError("coords and demands length must be same");
  }

  let vrpResponse;
  let routes;

  try {
    vrpResponse = await axios.post(
      "http://localhost:8000/route-optimize/auto",
      {
        coords,
        demands,
        vehicle_capacities,
      }
    );
  } catch (err) {
    throw new Error(`VRP service unreachable: ${err.message}`);
  }

  // Handling Error
  if (!vrpResponse.data || !Array.isArray(vrpResponse.data.routes)) {
    throw new Error("Invalid VRP response: routes missing");
  }

  routes = vrpResponse.data.routes;
  // Handling Error
  if (routes.length === 0) {
    return {
      success: true,
      message: "No routes generated by VRP at this time",
      routes: [],
    };
  }

  // Creating routes (Mapping)
  for (const route of routes) {
    const vehicleIndex = route.vehicle_id;

    // Handling Error
    if (!vehicles[vehicleIndex]) {
      throw new Error(`Invalid vehicle index returned: ${vehicleIndex}`);
    }

    route.vehicle_id = vehicles[vehicleIndex].vehicle_id;
    route.license_no = vehicles[vehicleIndex].license_no;

    let order = 1;
    const mappedStops = route.stops.map((stop) => {
      if (
        typeof stop.node !== "number" ||
        stop.node >= productionIndexMap.length
      ) {
        throw new Error(`Invalid stop node index: ${stop.node}`);
      }
      const p = productionIndexMap[stop.node] || null;

      return {
        order: order++,
        node: stop.node,
        production: p
          ? {
              _id: p._id,
              volume: p.volume,
              farmer: p.farmer,
              status: p.status,
            }
          : null,
        load_after_visit: stop.load_after_visit,
      };
    });

    route.stops = mappedStops;
  }

  return routes;
}

// Generate VRP solution route-wise
export async function generateRouteWiseAll() {
  const productions = await routingRepository.getPendingProduction();

  // Handling Error
  if (!productions || productions.length === 0) {
    throw new errors.NotFoundError(
      "No pending productions available at this moment"
    );
  }

  const requestBody = [];
  const depotCoords = [depot.lon, depot.lat];

  const productionIndexMap = [];

  for (let i = 1; i <= 6; i++) {
    const mapping = { route: i, productionIndexList: [null], vehicles: [] };
    const structure = {
      route: i,
      coords: [],
      demands: [],
      vehicle_capacities: [],
      vehicles: [],
    };

    structure.coords.push(depotCoords);
    structure.demands.push(0);

    productions.forEach((prod) => {
      if (Number(prod.farmer.route) === i) {
        structure.coords.push([
          prod.farmer.location.lon,
          prod.farmer.location.lat,
        ]);
        structure.demands.push(Number(prod.volume));
        mapping.productionIndexList.push(prod);
      }
    });

    const vehicle = vehicles.find((v) => v.route === i);

    // Handling Error
    if (!vehicle) {
      throw new errors.InternalError(`No vehicle assigned for route ${i}`);
    }
    mapping.vehicles.push(vehicle);
    structure.vehicles.push(vehicle);

    const caps = vehicles.filter((v) => v.route === i).map((v) => v.capacity);
    if (caps.length === 0)
      throw new errors.InternalError(
        "`No vehicle capacity found for route ${i}`"
      );
    structure.vehicle_capacities.push(...caps);

    productionIndexMap.push(mapping);
    requestBody.push(structure);
  }

  console.log(JSON.stringify(productionIndexMap));

  let vrpResponse;

  try {
    vrpResponse = await axios.post(
      "http://localhost:8000/route-optimize/route-wise/all",
      { requestBody }
    );
  } catch (err) {
    console.log(err);
    throw new errors.InternalError(`VRP service unreachable: ${err.message}`);
  }

  const routes = vrpResponse.data;
  // Handling Error
  if (routes.length === 0)
    throw new errors.InternalError("No routes generated by VRP at this time");

  const routeList = [];

  routes.forEach((route) => {
    const route_id = route["route"];

    const mapping = productionIndexMap.find((obj) => obj.route === route_id);

    // Handling Error
    if (!mapping) {
      throw new Error(`No production mapping found for route ${route_id}`);
    }

    route.routes.forEach((r) => {
      const mappedStops = r.stops.map((stop) => {
        const p = mapping.productionIndexList[stop.node] || null;
        let order = 1;
        return {
          order: order++,
          node: stop.node,
          production: p
            ? {
                _id: p._id,
                volume: p.volume,
                farmer: p.farmer,
              }
            : null,
          load_after_visit: stop.load_after_visit,
        };
      });

      r.stops = mappedStops;
      r.license_no = mapping.vehicles[r.vehicle_id].license_no;
      routeList.push(r);
    });
  });

  return routeList;
}

// Generate VRP solution route-wise by route
export async function generateRouteWise(routeId) {
  const productions = await routingRepository.getPendingProductionByRoute(
    routeId
  );

  // Handling Error
  if (productions.length === 0) {
    throw new errors.NotFoundError(
      "No pending productions available at this moment"
    );
  }

  const vehicleCapacities = [];
  const vehicleList = [];

  vehicles.forEach((vehicle) => {
    if (vehicle.route === Number(routeId)) {
      vehicleCapacities.push(vehicle.capacity);
      vehicleList.push(vehicle);
    }
  });

  // Handling Error
  if (vehicleCapacities.length === 0) {
    throw new Error(`No vehicles available for route ${routeId}`);
  }

  // Building VRP input
  const coords = [[depot.lon, depot.lat]];
  const demands = [0];
  const productionIndexMap = [null];

  productions.forEach((prod) => {
    coords.push([prod.farmer.location.lon, prod.farmer.location.lat]);
    demands.push(prod.volume);
    productionIndexMap.push(prod);
  });

  // Handling Error
  if (coords.length !== demands.length) {
    throw new errors.InternalError("coords and demands length must be same");
  }

  let vrpResponse;
  let routes;

  try {
    vrpResponse = await axios.post(
      "http://localhost:8000/route-optimize/auto",
      {
        coords,
        demands,
        vehicle_capacities: vehicleCapacities,
      }
    );
  } catch (err) {
    throw new Error(`VRP service unreachable: ${err.message}`);
  }

  // Handling Error
  if (!vrpResponse.data || !Array.isArray(vrpResponse.data.routes)) {
    throw new Error("Invalid VRP response: routes missing");
  }

  routes = vrpResponse.data.routes;
  // Handling Error
  if (routes.length === 0) {
    return {
      success: true,
      message: "No routes generated by VRP at this time",
      routes: [],
    };
  }

  console.log("Output: ", routes);

  // Creating routes (Mapping)
  for (const route of routes) {
    const vehicleIndex = route.vehicle_id;

    // Handling Error
    if (!vehicleList[vehicleIndex]) {
      throw new Error(`Invalid vehicle index returned: ${vehicleIndex}`);
    }

    route.vehicle_id = vehicleList[vehicleIndex].vehicle_id;
    route.license_no = vehicleList[vehicleIndex].license_no;

    let order = 1;
    const mappedStops = route.stops.map((stop) => {
      if (
        typeof stop.node !== "number" ||
        stop.node >= productionIndexMap.length
      ) {
        throw new Error(`Invalid stop node index: ${stop.node}`);
      }
      const p = productionIndexMap[stop.node] || null;

      return {
        order: order++,
        node: stop.node,
        production: p
          ? {
              _id: p._id,
              volume: p.volume,
              farmer: p.farmer,
              status: p.status,
            }
          : null,
        load_after_visit: stop.load_after_visit,
      };
    });

    route.stops = mappedStops;
  }

  return routes;
}

// Dispatch & save vehicle routes
export async function dispatchRoutes(routes) {
  if (!routes) throw new errors.BadRequestError("No routes to save");

  routes.forEach((route) => {
    route.status = "dispatched";
    route.stops.forEach((stop) => {
      if (stop.production !== null) {
        stop.production.status = "awaiting pickup";
      }
    });
  });

  // we should update productions also

  await routingRepository.saveRoutes(routes);
}

// Get all Pending Routes
export async function getPendingRoutesService(driver_id) {
  const pendingRoutes = await routingRepository.getPendingRoutesRepo(driver_id);
  return pendingRoutes;
}

// Get a Pending Route by ID
export async function getRouteById(route_id) {
  const route = await routingRepository.getRouteById(route_id);

  if (!route) {
    throw new errors.NotFoundError("Route not found");
  }

  return route;
}

export async function confirmProductionPickup(
  route_id,
  production_id,
  driver_id,
  collectedVolume
) {
  if (collectedVolume < 0)
    throw new errors.BadRequestError(
      "Collected volume cannot be smaller than 0"
    );

  const route = await routingRepository.getRouteById(route_id);

  if (!route) throw new errors.NotFoundError("Route not found");

  if (route.driver_id.toString() !== driver_id)
    throw new errors.UnauthorizedError("This route belongs to other driver");

  const stop = route.stops.find(
    (s) => s.production && s.production._id.equals(production_id)
  );

  if (!stop) {
    throw new errors.NotFoundError("Production stop not found");
  }

  if (stop.production.status === "collected") {
    return {
      alreadyProcessed: true,
    };
  }

  stop.production.status = "collected";
  stop.production.collectedVolume = collectedVolume;

  await routingRepository.saveRoute(route);

  return {
    alreadyProcessed: false,
  };
}

export async function issuePickupReportService(
  route_id,
  production_id,
  driver_id,
  failureReason
) {
  const route = await routingRepository.getRouteById(route_id);

  if (!route) throw new errors.NotFoundError("Route not found");

  if (route.driver_id.toString() !== driver_id)
    throw new errors.UnauthorizedError("This route belongs to other driver");

  const stop = route.stops.find(
    (s) => s.production && s.production._id.equals(production_id)
  );

  if (!stop) {
    throw new errors.NotFoundError("Production stop not found");
  }

  if (stop.production.status === "failed") {
    return {
      alreadyProcessed: true,
    };
  }

  stop.production.status = "failed";
  stop.production.collectedVolume = 0;

  stop.production.failure_reason = failureReason;

  await routingRepository.saveRoute(route);

  return {
    alreadyProcessed: false,
  };
}

// Canceling activated route
export async function cancelRouteActivation(route_id) {
  const route = await routingRepository.getRouteById(route_id);

  if (!route) {
    throw new errors.NotFoundError("Route not found");
  }

  route.status = "dispatched";

  const productionIds = [];

  for (const stop of route.stops) {
    const prod = stop.production;

    if (prod && prod.status !== "pending") {
      prod.status = "awaiting pickup";
      productionIds.push(prod._id);
    }
  }

  if (productionIds.length > 0) {
    await routingRepository.bulkUpdateProductionsToAwaiting(productionIds);
  }

  await routingRepository.saveRoute(route);

  return;
}

// Route activation
export async function activateRoute(driver_id, route_id) {
  const route = await routingRepository.getRouteById(route_id);

  if (!route) {
    throw new errors.NotFoundError("Route not found");
  }

  if (route.active && route.driver_id.toString() !== driver_id) {
    throw new errors.BadRequestError("Route is activated by another driver");
  }

  if (route.active && route.driver_id.toString() === driver_id) {
    return; // idempotent success
  }

  // Check if this driver has any other active route
  const otherActiveRoute = await Route.findOne({
    driver_id: driver_id,
    active: true,
    _id: { $ne: route_id }, // exclude current route
  });

  if (otherActiveRoute) {
    throw new errors.BadRequestError(
      "Cannot activate this route. Driver already has another active route."
    );
  }

  route.active = true;
  route.driver_id = driver_id;
  route.activatedAt = new Date();
  route.status = "inProgress";

  await routingRepository.saveRoute(route);

  return;
}

// Route Completion
export async function routeCompletetionService(route_id, driver_id) {
  const route = await routingRepository.getRouteById(route_id);

  if (!route) {
    throw new errors.NotFoundError("Route not found");
  }

  console.log(route.driver_id.toString());
  console.log(driver_id);

  if (route.active && route.driver_id.toString() !== driver_id) {
    throw new errors.BadRequestError("Route is activated by another driver");
  }

  if (route.status !== "inProgress") {
    throw new errors.BadRequestError(
      "Only in-progress routes can be completed"
    );
  }

  if (route.status === "completed") return;

  route.status = "completed";
  route.active = false;

  await routingRepository.saveRoute(route);

  return;
}

export async function getCompletedRoutesService(driver_id) {
  const result = await routingRepository.getCompletedRoutesByDriver(driver_id);

  if (!result || result.length === 0) return [];

  return result;
}

export async function getDispatchedService() {
  const result = await routingRepository.getDispatchedRoutes();

  return result;
}

export async function getInProgreeService() {
  const result = await routingRepository.getInProgressRoutes();

  return result;
}

export async function deleteRouteService(route_id) {
  if (!route_id) throw errors.BadRequestError("Route ID is empty");

  const result = await routingRepository.deleteRouteRepository(route_id);

  if (!result) throw errors.NotFoundError("Route not found");

  return;
}

export async function getHistoryService() {
  const result = await routingRepository.getCompletedAndCanceledRoutes();

  return result;
}
