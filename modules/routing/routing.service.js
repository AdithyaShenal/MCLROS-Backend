import axios from "axios";
import * as routingRepository from "./routing.repository.js";

export async function generateRoutesAuto() {
  const vehicles = [
    { vehicle_id: 1, capacity: 15, license_no: "ABC 10 10" },
    { vehicle_id: 2, capacity: 15, license_no: "ABC 20 20" },
    { vehicle_id: 3, capacity: 15, license_no: "ABC 30 30" },
    { vehicle_id: 4, capacity: 15, license_no: "ABC 40 40" },
  ];

  const vehicle_capacities = [15, 15, 15, 15];
  const depot = { lat: 7.019041, lon: 79.969565 };

  const productions = await routingRepository.getPendingProduction();

  // Handling Error
  if (productions.length === 0) {
    return {
      success: true,
      message: "No pending productions available at this moment",
    };
  }

  // Building VRP input
  const coords = [[depot.lon, depot.lat]];
  const demands = [0];
  const productionIndexMap = [null];

  productions.forEach((prod) => {
    coords.push([prod.farmer.location.lon, prod.farmer.location.lat]);
    demands.push(prod.volume);
    productionIndexMap.push(prod);
  });

  // Handling Error
  if (coords.length !== demands.length) {
    throw new Error("coords and demands length must be same");
  }

  let vrpResponse;
  let routes;

  try {
    vrpResponse = await axios.post(
      "http://127.0.0.1:8000/route-optimize/auto",
      {
        coords,
        demands,
        vehicle_capacities,
      }
    );
  } catch (err) {
    throw new Error(`VRP service unreachable: ${err.message}`);
  }

  // Handling Error
  if (!vrpResponse.data || !Array.isArray(vrpResponse.data.routes)) {
    throw new Error("Invalid VRP response: routes missing");
  }

  routes = vrpResponse.data.routes;
  // Handling Error
  if (routes.length === 0) {
    return {
      success: true,
      message: "No routes generated by VRP at this time",
      routes: [],
    };
  }

  // Creating routes
  for (const route of routes) {
    const vehicleIndex = route.vehicle_id;

    // Handling Error
    if (!vehicles[vehicleIndex]) {
      throw new Error(`Invalid vehicle index returned: ${vehicleIndex}`);
    }

    route.vehicle_id = vehicles[vehicleIndex].vehicle_id;
    route.vehicle_no = vehicles[vehicleIndex].license_no;

    let order = 1;
    const mappedStops = route.stops.map((stop) => {
      if (
        typeof stop.node !== "number" ||
        stop.node >= productionIndexMap.length
      ) {
        throw new Error(`Invalid stop node index: ${stop.node}`);
      }
      const p = productionIndexMap[stop.node] || null;

      return {
        order: order++,
        node: stop.node,
        production: p
          ? {
              _id: p._id,
              volume: p.volume,
              farmer: p.farmer,
            }
          : null,
        load_after_visit: stop.load_after_visit,
      };
    });

    route.stops = mappedStops;
  }

  await routingRepository.saveRoutes(routes);

  return routes;
}
